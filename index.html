<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="A quote generator that creates garbled quotes from existing quotes.">
        <meta name="author" content="ben">
        <link rel="apple-touch-icon-precomposed" href="images/favicon/apple-touch-icon-152x152.png">
        <meta name="msapplication-TileColor" content="#FFFFFF">
        <meta name="msapplication-TileImage" content="images/favicon/mstile-144x144.png">
        <link rel="icon" href="images/favicon/favicon-32x32.png" sizes="32x32">
        <title>Garbled Quote Generator</title>
        <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
        <link href="materialize/css/materialize.css" rel="stylesheet">
        <link href="style.css" rel="stylesheet">
        <link rel="stylesheet" href="materialize/css/materialize.min.css">
        <link rel="stylesheet" href="style.css">
    </head>
    <body>
        <div style="text-align: center;">
            <div data-empty-placeholder style="width: 30%; height: 80%; display: block; position: static; margin: auto;">
                <a id= "button" class="blue btn-large flow-text waves-effect waves-purple" style="width: 100%; margin: auto; position: static; text-align: center; font-size: 2em; margin-bottom: 10%; margin-top: 10%;">NEW QUOTE</a>
            </div>
        </div>
    <div class="cont">
    <h2 id="quotebox" style="font-style:italic; font-size: 5rem; position: absolute; width: 100%; text-align: center; color: rgb(0, 0, 0); text-shadow: 1px 1px 10px #00000092;">Quote</h2>
    </div>
    <script>
        let quoteBox = document.getElementById('quotebox');
        let quoteButton = document.getElementById('button');
        function randomNumber(min, max) {
            return Math.round(Math.floor(Math.random() * (max - min + 1)) + min);
        }
        async function getQuote() {
            try {
            const res = await fetch('quotesdb.json');
            if (!res.ok) throw new Error('The network response was not ok.');
            const data = await res.json();

            const quotes = Array.isArray(data) ? data : (Array.isArray(data.quotes) ? data.quotes : []);
            if (!quotes.length) throw new Error('JSON does not contain any quotes. Please add quotes before using.');
            const index = randomNumber(0, quotes.length - 1);

            // store fetched quote in a global variable and log it
            randomQuote = quotes[index].text ?? String(quotes[index]);
            console.log('randomQuote:', randomQuote);
            } catch (err) {
            console.error(err);
            console.log("Could not load quote.");
            garbleQuote(getQuote)
            }
        }
        function garbleQuote(quote) {
            if (!quote) return "No quote available. Please click 'NEW QUOTE' to fetch a quote.";
            quote = quote.trim();
            const re = /([^\w'’\-]*)([\w'’\-]+)([^\w'’\-]*)/g;
            let match;
            const tokens = [];
            while ((match = re.exec(quote)) !== null) {
                tokens.push({
                    leading: match[1] || '',
                    core: match[2],
                    trailing: match[3] || ''
                });
            }
            if (!tokens.length) return quote;

            // shuffle tokens so the words stay intact
            for (let i = tokens.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [tokens[i], tokens[j]] = [tokens[j], tokens[i]];
            }
            // strip terminal sentence punctuation from all trailing parts
            tokens.forEach(t => {
                t.trailing = t.trailing.replace(/[.?!]+$/g, '');
            });

            // ensure last token ends with a single period, keeping any closing punctuation (quotes, parens) after it
            const last = tokens[tokens.length - 1];
            const closingMatch = last.trailing.match(/([)\]'"”’]+)$/);
            let closing = '';
            if (closingMatch) {
                closing = closingMatch[1];
                last.trailing = last.trailing.slice(0, last.trailing.length - closing.length);
            }
            last.trailing = last.trailing + '.' + closing;

            // keep acronyms/all-caps, keep 'I', lower-case others
            tokens.forEach(t => {
                const core = t.core;
                if (/^[A-Z0-9]{2,}$/.test(core)) {
                    // likely an acronym, keep as is
                    t.core = core;
                } else if (core.toLowerCase() === 'i') {
                    t.core = 'I';
                } else {
                    t.core = core.toLowerCase();
                }
            });

            // capitalize first word of the sentence (after any leading punctuation)
            if (tokens.length) {
                const first = tokens[0];
                first.core = first.core.charAt(0).toUpperCase() + first.core.slice(1);
            }
            // join tokens with single spaces and remove any space before punctuation
                let result = tokens.map(t => t.leading + t.core + t.trailing).join(' ');
                result = result.replace(/\s+([,;:.!?])/g, '$1');
            // delete any 'the' at the end of the result
                 result = result.replace(/\s+the$/i, '');
            return result;
            // we clear the duplicate words, except for the words in the filterMask
            const filterMask = [
                'I',
                'you',
                'he',
                'she',
                'it',
                'we',
                'they',
                'me',
                'him',
                'her',
                'us',
                'them',
                'my',
                'your',
                'his',
                'her',
                'its',
                'our',
                'their',
                'mine',
                'yours',
                'hers',
                'ours',
                'theirs'
            ];
            const seen = new Set();
            const filtered = [];
            result.split(' ').forEach(word => {
                if (!seen.has(word) || filterMask.includes(word)) {
                    filtered.push(word);
                    seen.add(word);
                }
            });
            result = filtered.join(' ');

            // no leading/trailing whitespace
            result = result.trim();
            // make sure that any words from the filterMask2 are not at the end of the result, before the period.
            const filterMask2 = [
                'a',
                'an',
                'the',
                'and',
                'but',
                'or',
                'for',
                'nor',
                'so',
                'yet',
                'at',
                'by',
                'in',
                'of',
                'on',
                'to',
                'up',
                'as',
                'your'
            ];
            const lastWord = result.split(' ').pop();
            if (filterMask2.includes(lastWord)) {
                result = result.slice(0, result.lastIndexOf(' '));
            }
            return result;
        }
        quoteButton.addEventListener("click", () => {
            getQuote().then(() => {
                quoteBox.textContent = garbleQuote(randomQuote);
            });
        });
        </script>
        <script src="materialize/js/materialize.min.js"></script>
        </body>
    </html>
